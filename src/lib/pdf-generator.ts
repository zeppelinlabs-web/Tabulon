import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

export interface PdfOptions {
  pageSize: 'a4' | 'letter';
  orientation: 'portrait' | 'landscape';
  fontSize: 'small' | 'medium' | 'large';
  showRowNumbers: boolean;
  showMetadata: boolean;
  filename?: string;
}

const fontSizeMap = {
  small: { body: 8, header: 9, title: 14 },
  medium: { body: 10, header: 11, title: 16 },
  large: { body: 12, header: 13, title: 18 },
};

const primaryColor: [number, number, number] = [13, 148, 136]; // Teal

export function generatePdfFromCsv(content: string, options: PdfOptions): void {
  const { pageSize, orientation, fontSize, showRowNumbers, showMetadata, filename } = options;
  const sizes = fontSizeMap[fontSize];
  
  const doc = new jsPDF({
    orientation,
    unit: 'mm',
    format: pageSize,
  });

  const rows = parseCsv(content);
  const headers = rows[0] || [];
  const dataRows = rows.slice(1);

  // Add title
  doc.setFontSize(sizes.title);
  doc.setTextColor(30, 41, 59);
  doc.text('Data Export', 14, 20);

  // Add metadata
  if (showMetadata) {
    doc.setFontSize(sizes.body);
    doc.setTextColor(100, 116, 139);
    doc.text(`Generated: ${new Date().toLocaleString()}`, 14, 28);
    doc.text(`Rows: ${dataRows.length} | Columns: ${headers.length}`, 14, 34);
  }

  const startY = showMetadata ? 42 : 28;

  // Prepare table data
  const tableHeaders = showRowNumbers ? ['#', ...headers] : headers;
  const tableData = dataRows.map((row, index) => 
    showRowNumbers ? [String(index + 1), ...row] : row
  );

  // Generate table with autotable
  autoTable(doc, {
    head: [tableHeaders],
    body: tableData,
    startY,
    styles: {
      fontSize: sizes.body,
      cellPadding: 3,
      lineColor: [226, 232, 240],
      lineWidth: 0.1,
    },
    headStyles: {
      fillColor: primaryColor,
      textColor: [255, 255, 255],
      fontSize: sizes.header,
      fontStyle: 'bold',
      halign: 'left',
    },
    alternateRowStyles: {
      fillColor: [248, 250, 252],
    },
    columnStyles: showRowNumbers ? {
      0: { cellWidth: 12, halign: 'center', textColor: [100, 116, 139] },
    } : {},
    didDrawPage: (data) => {
      // Footer with page numbers
      const pageCount = doc.getNumberOfPages();
      doc.setFontSize(8);
      doc.setTextColor(100, 116, 139);
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      doc.text(
        `Page ${data.pageNumber} of ${pageCount}`,
        pageWidth / 2,
        pageHeight - 10,
        { align: 'center' }
      );
      doc.text('Generated by Tabulon', 14, pageHeight - 10);
    },
  });

  doc.save(filename || 'export.pdf');
}

export function generatePdfFromJson(content: string, options: PdfOptions): void {
  const { pageSize, orientation, fontSize, showMetadata, filename } = options;
  const sizes = fontSizeMap[fontSize];
  
  const doc = new jsPDF({
    orientation,
    unit: 'mm',
    format: pageSize,
  });

  let parsed: unknown;
  try {
    parsed = JSON.parse(content);
  } catch {
    parsed = content;
  }

  const formatted = JSON.stringify(parsed, null, 2);
  const lines = formatted.split('\n');

  // Add title
  doc.setFontSize(sizes.title);
  doc.setTextColor(30, 41, 59);
  doc.text('JSON Document', 14, 20);

  // Add metadata
  let currentY = 28;
  if (showMetadata) {
    doc.setFontSize(sizes.body);
    doc.setTextColor(100, 116, 139);
    doc.text(`Generated: ${new Date().toLocaleString()}`, 14, currentY);
    currentY += 6;
    doc.text(`Lines: ${lines.length}`, 14, currentY);
    currentY += 10;
  } else {
    currentY += 4;
  }

  // Render JSON with syntax highlighting simulation
  doc.setFont('courier', 'normal');
  doc.setFontSize(sizes.body);
  
  const pageHeight = doc.internal.pageSize.getHeight();
  const pageWidth = doc.internal.pageSize.getWidth();
  const lineHeight = sizes.body * 0.5;
  const marginBottom = 20;

  lines.forEach((line, index) => {
    if (currentY > pageHeight - marginBottom) {
      doc.addPage();
      currentY = 20;
      
      // Add header on new pages
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(8);
      doc.setTextColor(100, 116, 139);
      doc.text('JSON Document (continued)', 14, 12);
      doc.setFont('courier', 'normal');
      doc.setFontSize(sizes.body);
      currentY = 20;
    }

    // Line number
    doc.setTextColor(150, 150, 150);
    doc.text(String(index + 1).padStart(4, ' '), 14, currentY);

    // Determine color based on content
    if (line.includes('":')) {
      // Key
      doc.setTextColor(13, 148, 136); // Primary teal
    } else if (line.includes('"') && !line.includes(':')) {
      // String value
      doc.setTextColor(22, 163, 74); // Green
    } else if (/:\s*\d/.test(line)) {
      // Number
      doc.setTextColor(217, 119, 6); // Amber
    } else if (/:\s*(true|false)/.test(line)) {
      // Boolean
      doc.setTextColor(37, 99, 235); // Blue
    } else {
      doc.setTextColor(30, 41, 59);
    }

    doc.text(line, 28, currentY);
    currentY += lineHeight;
  });

  // Add page numbers
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(8);
    doc.setTextColor(100, 116, 139);
    doc.text(
      `Page ${i} of ${pageCount}`,
      pageWidth / 2,
      pageHeight - 10,
      { align: 'center' }
    );
    doc.text('Generated by Tabulon', 14, pageHeight - 10);
  }

  doc.save(filename || 'export.pdf');
}

export function generatePdfFromXml(content: string, options: PdfOptions): void {
  const { pageSize, orientation, fontSize, showMetadata, filename } = options;
  const sizes = fontSizeMap[fontSize];
  
  const doc = new jsPDF({
    orientation,
    unit: 'mm',
    format: pageSize,
  });

  // Format XML with indentation
  const formatted = formatXml(content);
  const lines = formatted.split('\n');

  // Add title
  doc.setFontSize(sizes.title);
  doc.setTextColor(30, 41, 59);
  doc.text('XML Document', 14, 20);

  // Add metadata
  let currentY = 28;
  if (showMetadata) {
    doc.setFontSize(sizes.body);
    doc.setTextColor(100, 116, 139);
    doc.text(`Generated: ${new Date().toLocaleString()}`, 14, currentY);
    currentY += 6;
    doc.text(`Lines: ${lines.length}`, 14, currentY);
    currentY += 10;
  } else {
    currentY += 4;
  }

  // Render XML
  doc.setFont('courier', 'normal');
  doc.setFontSize(sizes.body);
  
  const pageHeight = doc.internal.pageSize.getHeight();
  const pageWidth = doc.internal.pageSize.getWidth();
  const lineHeight = sizes.body * 0.5;
  const marginBottom = 20;

  lines.forEach((line, index) => {
    if (currentY > pageHeight - marginBottom) {
      doc.addPage();
      
      // Add header on new pages
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(8);
      doc.setTextColor(100, 116, 139);
      doc.text('XML Document (continued)', 14, 12);
      doc.setFont('courier', 'normal');
      doc.setFontSize(sizes.body);
      currentY = 20;
    }

    // Line number
    doc.setTextColor(150, 150, 150);
    doc.text(String(index + 1).padStart(4, ' '), 14, currentY);

    // Simplified coloring for XML
    if (line.includes('<?') || line.includes('?>')) {
      doc.setTextColor(100, 116, 139); // Declaration - gray
    } else if (line.includes('</') || line.match(/<\w/)) {
      doc.setTextColor(13, 148, 136); // Tags - primary
    } else {
      doc.setTextColor(30, 41, 59);
    }

    // Truncate long lines
    const maxChars = orientation === 'landscape' ? 120 : 80;
    const displayLine = line.length > maxChars ? line.substring(0, maxChars) + '...' : line;
    
    doc.text(displayLine, 28, currentY);
    currentY += lineHeight;
  });

  // Add page numbers
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(8);
    doc.setTextColor(100, 116, 139);
    doc.text(
      `Page ${i} of ${pageCount}`,
      pageWidth / 2,
      pageHeight - 10,
      { align: 'center' }
    );
    doc.text('Generated by Tabulon', 14, pageHeight - 10);
  }

  doc.save(filename || 'export.pdf');
}

function parseCsv(content: string): string[][] {
  const lines = content.trim().split('\n');
  return lines.map(line => {
    const cells: string[] = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        cells.push(current.trim());
        current = '';
      } else {
        current += char;
      }
    }
    cells.push(current.trim());
    return cells;
  });
}

function formatXml(xml: string): string {
  let formatted = '';
  let indent = 0;
  
  xml = xml.replace(/></g, '>\n<');
  
  xml.split('\n').forEach(line => {
    line = line.trim();
    if (!line) return;
    
    if (line.startsWith('</')) {
      indent = Math.max(0, indent - 1);
    }
    
    formatted += '  '.repeat(indent) + line + '\n';
    
    if (!line.startsWith('<?') && !line.startsWith('</') && !line.endsWith('/>') && !line.includes('</')) {
      indent++;
    }
  });
  
  return formatted;
}
